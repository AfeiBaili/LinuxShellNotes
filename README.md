# Linux notes

Linux是现在最流行的服务器,性能高,速度快。对比Windows系统少了图形化界面,对于服务器来说,系统根本不需要图形化界面

## Vim编辑器

vi是Unix最通用的文本编辑器,vim是它的升级版,可以主动分开字体颜色来检查语法的正确性。vi一共有三种模式,一般模式,编辑模式,命令模式

### 一般模式

通常用于删除、复制、粘贴、撤销

| 语法    | 功能描述                 |
|-------|----------------------|
| yy    | 复制一行(仅复制不粘贴)         |
| p     | 粘贴                   |
| y(n)y | 复制n行                 |
| u     | 撤销上一步                |
| dd    | 删除当前行                |
| d(n)d | 删除n行                 |
| x     | 剪切一个字符,相当于del键       |
| X     | 剪切一个字符,相当于backspace键 |
| yw    | 复制一个词                |
| dw    | 删除一个词                |
| ^     | 移动到行头                |
| $     | 移动到行尾                |
| w     | 移动到下一个词头             |
| e     | 移动到下一个词尾             |
| (n)G  | 移动到n行                |
| gg    | 移动到行头                |
| G     | 移动到行尾                |
| r     | 替换单个词                |
| R     | 进入替换模式               |

### 编辑模式

进入编辑模式的按键语法,触发以下按键都能进入编辑模式,回到一般模式按下Esc键

| 语法 | 功能     |
|----|--------|
| i  | 当前光标前面 |
| I  | 此行开头   |
| a  | 当前光标后面 |
| A  | 此行结尾   |
| o  | 此行的下一行 |
| O  | 此行的上一行 |

### 命令模式

在一般模式下按:或者/进入命令模式

| 语法        | 功能               |
|-----------|------------------|
| :q        | 退出编辑器            |
| :q!       | 不保存强制退出编辑器       |
| :w        | 保存更改             |
| :wq       | 保存并退出            |
| :wq!      | 有权限可以强制保存并退出只读文件 |
| /要查找的词    | 搜索字词             |
| :noh      | 搜索字词             |
| :set nu   | 显示行号             |
| :set nonu | 关闭行号             |
| :s/词/词    | 更改第一个词           |
| :s/词/词/g  | 替换一行词            |
| :%s/词/词/g | 替换全文第一个词         |
| :%s/词/词/g | 替换全文所有词          |

## 网络配置

在Unix中衍生出了Linux,又在Linux内核后面衍生了更多Linux,不同的Linux版本差异可能不大,但是Ubuntu和CentOS操作系统中配置静态IP是不相同的


> Debian -> Ubuntu:
> 使用yaml配置文件进行配置,配置文件在/etc/netplan/中的01-network-manager-all.yaml配置文件,配置完之后输入`netplan apply`
> 命令进行应用

```yaml
network:
  version: 2
  renderer: NetworkManager
  # 网卡
  ethernets:
    # 网卡名称
    ens33:
      # 关闭更新IP地址
      dhcp4: no
      # IP地址和网段
      addresses: [ 192.168.136.150/24 ]
      # 网关地址
      gateway4: 192.168.136.55
      # DNS服务器
      nameservers:
        addresses: [ 192.168.136.55 ]
```

> RedHat -> CentOS:/etc/sysconfig/network-scripts/ifcfg-ens33路径是CentOS的网络配置文件路径地址

```properties
# 将此选项改成static，意为静态的
BOOTPROTO="static"
# 此选项改为yes
ONBOOT="yes"
# 添加项，意为IP地址
IPADDR=192.168.0.0
# 添加项，意为网关地址
GATEWAY=192.168.0.0
# 添加项，意为DNS服务器，可以多添加DNS服务器
DNS1=192.168.0.0
```

主机名配置在/etc/hostname文件中

## 基本命令

在Linux中数据文件并不是实时保存的,在关机前要先保存文件再关机,在关机时Linux会自动调用`sync`命令,用于同步硬盘资源

`halt`:停机不断电命令

`poweroff`:关机断电

`reboot`:重启系统

`shutdown [选项] 时间`:输入shutdown会等待一分钟关机,使用`shutdown -c`取消关机命令

| 参数  | 功能           |
|-----|--------------|
| -H  | 相当于--halt,停机 |
| -r  | 相当于reboot,重启 |
| now | 立刻关机         |
| 时间  | 定时关机         |

### 手册命令

`man [命令]`:获取指令帮助信息

`type [命令]`:查看命令来源

## 文件目录命令

`ls [命令]`:查看目录内容不显示隐藏文件

| 参数 | 功能       |
|----|----------|
| -l | 列出详细文件内容 |
| -a | 所有文件和目录  |
| -r | 倒序       |
| -t | 根据时间排序   |
| -R | 递归目录     |

`mkdir [文件名]`:创建一个目录,使用-p参数嵌套创建

```shell
mkdir -p a/b/c
```

`rmdir [文件名]`:删除一个目录,使用-p参数嵌套删除

```shell
rmdir -p a/b/c
```

`touch [文件名]`:创建一个空文件

`cp [参数] 源文件 目标文件`:复制文件或目录-r参数递归复制

`rm [参数] [文件名]`:删除一个文件或目录

| 参数 | 功能       |
|----|----------|
| -r | 递归删除     |
| -f | 删除时无须确认  |
| -v | 删除展示详情信息 |

`mv 源文件 [目录|文件名]`:移动文件或目录到指定位置

`cat [参数] 文件名`:查看文件内容,-n参数可以显示行号

`more [文件名]`:分屏显示文件内容

| 操作     | 功能       |
|--------|----------|
| space  | 向下翻页     |
| Enter  | 翻一行      |
| q      | 退出查看器    |
| Ctrl+f | 向下滚动一屏   |
| Ctrl+b | 向上滚动一屏   |
| =      | 输出当前行号   |
| :f     | 输出文件名和行号 |

`less [文件名]`:类似more但是比more更加强大,而且less是实时加载的,就算很大的文件打开也可以实时查看

| 操作       | 功能     |
|----------|--------|
| space    | 向下翻动一页 |
| pagedown | 向下翻动一页 |
| pageup   | 向上翻动一页 |
| /词       | 向下查找词  |
| ?词       | 向上查找词  |
| q        | 退出less |

`echo [参数] 内容`:打印内容到控制台,-e参数可以支持制表符

`内容 > 文件`:将输出内容打印到文件,会被覆盖

`内容 >> 文件`:将内容重定向到文件,会在文件末尾追加

`head [参数] 行数`:展示文件开头的行数,默认十行,-n指定行数

`tail [参数] 行数`:展示文件末尾的行数,默认十行,-n指定行数,-f参数实时更新文件末尾内容

`ln [参数] 源文件 软连接名`:-s参数创建一个软连接,类似Windows的快捷方式,不加-s创建硬链接,删除原文件但是还存在硬链接就不会删除文件,硬连接数为0才真正删除文件

`history [参数|行数]`:查看历史输入命令,可指定行数,-c删除历史命令

`cd -`:切换上一个目录

### 文件权限

Linux中文件有不同的权限,比如组权限。**drwx------ 5 root root 4096 9月 26 20:27 snap/** 这行加粗的文本是使用ll命令打印出的文件属性,
其中

| d    | rwx        | ---     | ---      |
|------|------------|---------|----------|
| 文件类型 | 文件所属用户执行权限 | 所属组用户权限 | 其它用户执行权限 |

d:代表这是一个目录  
r:代表可读权限  
w:代表可写权限  
x:代表可执行权限

`chmod [参数] [ugoa] [+-=] [rwx]`:更改文件权限,使用-R参数递归执行

> 也可以使用数字待变权限,x是1w是2r是4

```shell
# 更改file的所属用户执行权限
chmod 100 file
# 设置所有用户和组的读写执行权限
chmod 777 file
```

`chown [参数] 用户 文件`:更改文件的所属用户,-R递归执行

`chgrp 组名 文件`:更改文件的所属组

### 文件查找

`find [范围] [参数]`:查找文件

| 参数    | 功能                                                                   |
|-------|----------------------------------------------------------------------|
| -name | 根据文件名查找                                                              |
| -user | 查找属于指定用户的文件                                                          |
| -size | 按照指定文件大小查找,单位<br/>b-块<br/>c-字节<br/>w-字<br/>k-千字节<br/>M-兆字节<br/>G-吉字节 |

`|`:将上一个查找的内容传到下一个指令

`grep [参数] 词`:根据词显示行内容,-n显示行号

### 压缩和解压

`gzip 文件`:压缩文件为*.gz结尾的文件

`gunzip 文件`:解压文件必须为*.gz结尾的文件

`zip [参数] 压缩名 文件`:压缩zip文件,-r压缩目录

`unzip [参数]`:解压zip文件,-d指定文件位置

`tar [参数]`:打包压缩或解压

| 参数 | 功能       |
|----|----------|
| -c | 产生.tar文件 |
| -v | 显示详情信息   |
| -f | 指定文件名    |
| -z | 打包并压缩    |
| -x | 解包.tar文件 |
| -C | 解压指定目录   |

```shell
# 打包压缩
tar -zcvf a.gz.tar a.txt
# 解包解压
tar -zxvf a.gz.tar a.txt
```

## 磁盘查看和占用

`du [参数] [目录|文件]`:查看文件占用大小

| 参数            | 功能                |
|---------------|-------------------|
| -h            | 显示较易读的方式          |
| -a            | 不仅要查看子目,大小，还要包括文件 |
| -c            | 显示所有文件的大小         |
| -s            | 只显示总和             |
| --max-depth=数 | 显示指定深度            |

`df [参数]`:查看磁盘分区,-h显示易读方式

`free [参数]`:查看内存占用,-h显示易读方式

`lsblk [参数]`:查看分区,-f查看文件系统

`mount [位置] [挂载点]`:将磁盘挂载到一个位置

`umount [挂载点]`:卸载挂载点

`fdisk [参数|硬盘设备名]`:查看或使用分区,-l参数查看磁盘分区

## 关于时间的命令

`date [参数|[格式化]]`:显示当前时间

| 语法  | 功能       |
|-----|----------|
| +%Y | 显示当前年份   |
| +%y | 显示当前两位年份 |
| +%m | 显示当前月份   |
| +%d | 显示当前哪一天  |
| +%H | 显示时数     |
| +%M | 显示分钟     |
| +%S | 显示秒数     |
| +%s | 显示时间戳    |

```shell
# 显示当前时间
date "+%Y/%m/%d %H:%M:%S"
# 设置系统时间
date -s "2024-10-01 15:02:54"
```

`crontab [参数]`:系统定时任务

> crontab后台有一个守护进程叫cron

| 参数 | 功能              |
|----|-----------------|
| -e | 编辑一个crontab定时任务 |
| -l | 查询crontab任务     |
| -r | 删除当前用户所有任务      |

> 用`* * * * *`代表,分钟、小时、天数、月数、星期

| 位数   | 含义        | 范围   |
|------|-----------|------|
| 第一个* | 一小时中的第几分钟 | 0-59 |
| 第二个* | 一天中的第几小时  | 0-23 |
| 第三个* | 一月中的第几天   | 1-31 |
| 第四个* | 一年中的第几月   | 1-12 |
| 第五个* | 一周中的星期几   | 0-7  |

## 用户管理命令

`useradd`:添加用户
`useradd -g 组名 用户名`:创建用户并添加到组里

`userdel 用户名`:删除用户

`passwd 用户名`:给用户创建密码

`id 用户名`:展示用户id信息

> 在/etc/passwd文件内容中含有所有用户的信息

`su 用户名`:切换用户

> 切换之后并不是在本shell环境下切换的二是在shell中内嵌了一个shell,使用exit退出shell,输入exit从里到外进行关闭

`who am i`:显示当前用户进程的信息

`whoami`:显示当前用户名

`sudo [命令]`:为当前用户设置root权限

> 需要在/etc/sudoers文件中添加

```
# CentOS配置
root        ALL=(ALL) ALL
username    ALL=(ALL) ALL
# 可以不输密码
username    ALL=(ALL) NOPASSWD:ALL
```

`usermod -g 组名 用户名`:修改用户的组

`groupmod -n 组名 旧组名`:修改组的名

`groupdel`:删除组

> 在/etc/group文件中查看所有组

## 进程管理

`ps [参数]`:查看系统运行的进程

> ps命令只查看当前shell的进程

| 参数 | 功能                    |
|----|-----------------------|
| a  | 列出带有终端的所有用户的进程        |
| x  | 列出当前用户的所有进程,包括没有终端的进程 |
| u  | 面向用户友好的显示风格           |
| -e | 列出所有进程                |
| -u | 列出某个用户关联的所有进程         |
| -f | 显示完整格式的进程列表           |

`kill PID`:通过进程号杀死进程,-9强制杀死

`killall 进程名称`:通过进程号杀死进程

`top [参数]`:实时监控进程

| 参数    | 功能             |
|-------|----------------|
| -d 秒数 | 指定更新秒数，默认3秒    |
| -i    | 使top不显示闲置或僵尸进程 |
| -p    | 监控PID来指定监控     |

| 操作 | 功能        |
|----|-----------|
| P  | 用CPU排序,默认 |
| M  | 使用内存排序    |
| N  | 通过PID排序   |
| q  | 退出top     |

`netstat [参数]`:显示网络状态和端口占用信息

| 参数 | 功能               |
|----|------------------|
| -a | 显示所有正在监听和为监听的套接字 |
| -n | 拒绝显示别名,显示数字      |
| -l | 列出只监听的服务状态       |
| -p | 表示显示哪个进程在调用      |

# Shell notes

声明执行shell,在文件开头一行写

```
#!/bin/bash
...
```

### 执行shell脚本的方法

```shell
# 使用bash执行
bash shell.sh
# 使用sh执行
sh shell.sh
# 使用绝对路径执行(需要可执行权限)
/root/shell.sh
# 使用相对路径执行(需要可执行权限)
./shell.sh
# 使用source执行
source shell.sh
# 使用.执行
. shell.sh
```

> 注意用"."和"source"执行的脚本和其他执行的方式不同,其他的方式是在shell中创建一个新shell执行,而"."和"source"
> 是在当前shell中执行,这在声明局部变量中有用

查看系统所有变量

```shell
set 
```

### 定义变量

自定义变量,变量没有类型,全是字符串类型

```shell
VAR=hi,Afei
```

变量没有数字运算

```shell
VAR=1+5
echo $VAR
# 打印结果是
# 1+5
```

如果要执行数学运算要用$(())或$[]包裹运算表达式

```shell
VAR=$((1+5))
echo $VAR
# 打印结果是
# 6
```

使用readonly设置只读变量

```shell
readonly VAR=$((1+5))
echo $VAR
```

使用unset撤销变量

```shell
VAR=123
echo $VAR
# 输出为
#123
unset VAR
# 输出为
# 空行
```

### 特殊变量

特殊变量$n,n代表一个数字用于对脚本传参数,`$0`代表脚本的名称,`$1`代表第一个参数、,`$2`代表第二个参数、`$3`
代表第三个个参数以此类推。n到了10以后就需要用`${10}`大括号包裹起来

`$*`:将所有的参数视为一个整体

`$@`:将参数视为一个集合

`$?`:上一个命令返回的值都会在$?这个特殊变量中

### 运算

使用"expr 值 运算符 值"进行运算,必须带上空格

```shell
expr 1 + 2
#输出3 
```

使用expr运算命令很不方便,我们可以使用`$[1*2]`来进行数学运算,也可以用另一种方式`$((1*2))`

**使用$(内容)或者\`内容\`进行命令替换**,为了防止将命令解析成字符串

### 条件判断

**常用判断条件**

| 语法  | 功能       |
|-----|----------|
| -eq | 等于       |
| -ne | 不等于      |
| -lt | 小于       |
| -le | 小于等于     |
| -gt | 大于       |
| -ge | 大于等于     |
| -r  | 可读的      |
| -w  | 可写的      |
| -x  | 可执行的     |
| -e  | 文件存在     |
| -f  | 文件存在 是文件 |
| -d  | 文件存在 是目录 |

多条件判断 && 表示前一条命令执行成功,才执行下一条命令 || 表示上一条执行失败才执行下一条命令

**if判断**

```shell
if [ 条件 ]; then
    #程序
fi
```

多分支

```shell
if [ 条件 ]; then
    #程序
elif [ 条件 ]; then
    #程序
else 
    #程序
fi
```

**case语句**

```shell
case $1 in
1)
  echo "我是1"
;;
2)
  echo "我是2"
::
*)
  echo "我不是1和2"
::
esac  
```

### 循环

**for循环**

```shell
for (( i = 0; i < n; i++ )); do
    echo $i
done
```

> 为什么for括号中可以写<号,因为使用了双小括号

```shell
a=1
if (($a<2));then echo "ok";else echo "not ok";fi 
#输出ok
```

for的另一种写法

```shell
for i in {1..100};do
  echo $i
done
```

**while循环**

```shell
a=1
while [ $a -lt 100 ]; do
    a=$[$a+1]
    echo $a
done
```

### 读取控制台输入

使用read命令进行读取控制台输入

| 参数 | 功能   |
|----|------|
| -p | 描述   |
| -t | 等待时间 |

```shell
#示例
read -p "请确认：" isSure
if [ $isSure = "yes" ]; then echo "ok yes"; else echo "no"; fi
```

### 函数

自定义一个函数

```shell
function _111() {
    echo 111
}

_111
```